<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Karol Stasiak's Blog]]></title>
  <link href="http://KarolS.github.io/categories/programming/atom.xml" rel="self"/>
  <link href="http://KarolS.github.io/"/>
  <updated>2014-04-29T01:07:10+02:00</updated>
  <id>http://KarolS.github.io/</id>
  <author>
    <name><![CDATA[Karol Stasiak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[From explicit nested monads to Kleisli arrows over monad transformers]]></title>
    <link href="http://KarolS.github.io/blog/2014/04/29/from-nested-monads-to-kleisli-arrows-over-monad-transformers/"/>
    <updated>2014-04-29T01:15:00+02:00</updated>
    <id>http://KarolS.github.io/blog/2014/04/29/from-nested-monads-to-kleisli-arrows-over-monad-transformers</id>
    <content type="html"><![CDATA[<p>Recently at work I had a task of developing a small tool that could display charts with progress of our data extraction over time. </p>

<p>After each iteration, results of data extraction were stored in several directories and compared against a handwritten reference set.</p>

<p>In short, this is the directory structure:</p>

<p><code>plain
|--+ batch1
|  |--+ correct
|  |  `--- data.txt
|  |--+ guessed
|  |  |--- data.00000145a8ab68b9.txt
|  |  |--- data.00000145a92a530f.txt
|  |  `--- data.0000014594039f5b.txt
|  |--- input1.pdf
|  |--- input2.pdf
|  `--- input3.pdf
`--+ batch2
   |--+ correct
   |  `--- data.txt
   |--+ guessed
   |  |--- data.00000145a8ab68b9.txt
   |  |--- data.00000145a92a530f.txt
   |  `--- data.0000014594039f5b.txt
   |--- input4.pdf
   |--- input5.pdf
   `--- input6.pdf
</code></p>

<p>The hexadecimal numbers are timestamps in milliseconds since Unix epoch.</p>

<p>Each file consisted of records in the format:</p>

<p><code>plain
input1.pdf value from the first file
input2.pdf value from the second file
input3.pdf value from the third file
</code></p>

<p>Long story short, there was no difference what programming language I would write the tool in, so I picked Haskell. Let’s ignore most details of the implementation. What’s important for this entry, is that I implemented the following functions:</p>

<p>```haskell</p>

<p>allCorrectFiles :: [FilePath]  -&gt; IO [FilePath]
allGuessedFiles :: [FilePath]  -&gt; IO [(LocalTime, FilePath)]
readDataFile :: FilePath -&gt; IO [(Entry, String)]
getAllData :: [FilePath] -&gt; IO ([(Entry, String)], [(LocalTime, Entry, String)])</p>

<p>```</p>

<p>The initial implementation of the <code>getAllData</code> function was straightforward, yet a bit clunky:</p>

<p><code>haskell
getAllData subDirs = do
	correctFiles &lt;- allCorrectFiles subDirs
	guessedFiles &lt;- allGuessedFiles subDirs
	correctData &lt;- mapM readDataFile correctFiles
	guessedData &lt;- forM guessedFiles $ \(t,f) -&gt;
		x &lt;- readDataFile f
		return $ map (\(e,s) -&gt; (t,e,s)) x
	return (concat correctData, concat guessedData)
</code></p>

<p>This code is quite ugly. The especially jarring were the <code>return $ map</code> combination and <code>concat</code>s in the final line.</p>

<p>After a while, I noticed that all the functions I call from the <code>getData</code> function are of type <code>a -&gt; IO [b]</code>. A double monad. So, I added <code>transformers</code> library to my project and rewritten that function as:</p>

<p><code>haskell
getAllData subDirs = do
	correctData &lt;- runListT $ do
		f &lt;- ListT $ allCorrectFiles subDirs
		x &lt;- ListT $ readDataFile f
		return x	
	guessedData &lt;- runListT $ do
		(t,f) &lt;- ListT $ allGuessedFiles subDirs
		x &lt;- ListT $ readDataFile f
		return (t, fst x, snd x)
	return (correctData, guessedData)
</code></p>

<p>Now it looks way more uniform.</p>

<p>This was my first piece of code using monad transformers, so I will explain what’s going on to everyone who was in the same situation as me before understanding it.</p>

<p><code>IO</code> is a monad, so is <code>[]</code>. For some monads, if you wrap them in another monad, you still get something that can be used like a monad. One of such monads is <code>[]</code>.</p>

<p>For every monad <code>m</code> and type <code>a</code>, <code>m [a]</code> is a monad over <code>a</code>. But in order for Haskell to treat it as one singular monad, we need to wrap it. And that’s what <code>ListT</code> is for. </p>

<p>So <code>allCorrectFiles subDirs</code> returns <code>IO [FilePath]</code>, and after wrapping it with <code>ListT</code> we get <code>ListT IO FilePath</code>.</p>

<p>This way, we stack our monadic effects: we both iterate over elements of a list, and track impure side effects. If the <code>readDataFile</code> or <code>allGuessedFiles</code> were pure, we would use <code>[]</code> monad. If they were impure, but returned only one element, we’d use <code>IO</code> monad. By wrapping <code>IO [a]</code> into <code>ListT</code>, we can use them both.</p>

<p>Since the results of inner <code>do</code> blocks are now of type <code>ListT IO a</code>, we unwrap them with <code>runListT</code>.</p>

<p>Note that since <code>ListT</code> allowed <code>&lt;-</code> operator to unwrap not only the <code>IO</code> monad, but also the list monad, we didn’t end up with lists of lists and we no longer needed to <code>concat</code> those lists together.</p>

<p>The code got less ugly, but it also got a bit longer. Could I get it shorter?</p>

<p>The answer was yes, but only a teeny tiny bit, and involved some more complicated machinery. Arrows.</p>

<p>The trivial arrow instance for functions is easy to understand: <code>&gt;&gt;&gt;</code> behaves like flipped function composition, and there are several combinators, like <code>&amp;&amp;&amp;</code>, <code>***</code>, <code>first</code> and <code>second</code> that make it easier to work with 2-element tuples. </p>

<p>Since the return value from the <code>allGuessedFiles</code> was a list of 2-element tuples in an IO monad, and I only operated on the second element before fusing them together, I decided to use arrows. Luckily, the <code>base</code> library contains definitions for monadic arrows, which are to <code>&gt;&gt;=</code> as trivial arrows are to <code>.</code>.</p>

<p>The code had to involve even more wrapping and unwrapping. Here it is:</p>

<p><code>haskell
getAllData subDirs = do
	correctData &lt;- runKL subDirs $ 
		kl allCorrectFiles &gt;&gt;&gt; kl readDataFile
	guessedData &lt;- runKL subDirs $ 
		kl allGuessedFiles &gt;&gt;&gt; second (kl readDataFile) &gt;&gt;^ \(a,(b,c)) -&gt; (a,b,c)
	return (correctData, guessedData)
	where 
		kl f = Kleisli $ ListT . f
		runKL x ar = runListT $ runKleisli ar x
</code></p>

<p>Now I do believe I owe you some explanations.</p>

<p>Let’s start with the definition of <code>kl</code>. <code>f</code> is of type <code>a -&gt; m [b]</code>, where <code>m</code> is a monad. After composing it with <code>ListT</code>, we get <code>ListT . f</code> of type <code>a -&gt; ListT m b</code>, where <code>ListT m</code> is a monad now.</p>

<p><code>Kleisli</code> wraps our function into a Kleisli arrow (of type <code>Kleisli (ListT m) a b</code>), so Haskell knows that when we join arrows together, we don’t want to abstract <code>.</code> but <code>&gt;&gt;=</code>. This way, <code>kl f &gt;&gt;&gt; kl g</code> means the same as <code>\x -&gt; f x &gt;&gt;= g</code>, where <code>f &gt;&gt;&gt; g</code> would mean  <code>\x -&gt; (g . f) x</code>.</p>

<p><code>runKL</code> applies our arrow and unwraps the <code>ListT</code> transformer. I reversed the argument order of <code>runKleisli</code> for convenience.</p>

<p>So how is the <code>guessedData</code> calculated? <code>allGuessedFiles</code> returns <code>IO [(LocalTime, FilePath)]</code>. <code>second</code> makes its argument to be applied only to the second argument of the input tuple, so <code>second readDataFile</code> would be of type <code>(a, FilePath) -&gt; IO[(a,(Entry, String))]</code>*, but since we used <code>kl</code>, it’s actually <code>Kleisli (ListT IO) (a, FilePath) (a,(Entry, String))</code>.</p>

<p><em>* Note: I kinda simplified here a bit and technically this type is wrong.</em></p>

<p>The last function, which is a lambda expression, was lifted into a Kleisli arrow with the <code>&gt;&gt;^</code> operator. In case of Kleisli arrows, such lifting is equivalent to <code>\f -&gt; (return . f)</code>. It turns a function of type <code>a-&gt;b</code> into a function of type <code>a -&gt; m b</code> wrapped into a Kleisli.</p>

<p>I also took a peek at the <code>arrow-list</code> package, which provides its own definitions of equivalents for <code>kl</code> and <code>runKL</code>, but I decided to not use it, since it would give little value.</p>

<p><strong>So, was it worth it?</strong></p>

<p>In some sense, yes. I have learnt what monad transformers and Kleisli arrows can be used for. The main problem is that the problem I had to solve was too small for such complex machinery. The transformers made the code more uniform, which allowed application of arrows, while arrows would have made code mode compact if it was more complex.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hOCR4J 0.1 released]]></title>
    <link href="http://KarolS.github.io/blog/2014/01/03/hocr4j-0-1-released/"/>
    <updated>2014-01-03T00:11:00+01:00</updated>
    <id>http://KarolS.github.io/blog/2014/01/03/hocr4j-0-1-released</id>
    <content type="html"><![CDATA[<p>I would like to announce the release of a Java library for parsing hOCR documents: <strong>hOCR4J</strong>. You can <a href="https://github.com/KarolS/hOCR4J">download it from here</a>. I’m planning to get it to Sonatype too, so you may be able to get it from there in the near future.</p>

<p>hOCR is an output format used by OCR programs, including <a href="http://code.google.com/p/tesseract-ocr">Tesseract</a>. It contains information about all the OCR’d words, their position, and their assumed organisation into lines and paragraphs. Currently, hOCR4J was tested to work with Tesseract-generated hOCR’s, I plan to test other OCR programs in the future.</p>

<p>hOCR4J parses hOCR documents, creates an immutable model for them (nice when using functional programming style), and provides various tools to manipulate and modify them.</p>

<p>hOCR4J makes a good starting point when developing an application which extracts data from OCR’d documents that have non-trivial layouts.</p>

<!-- more -->

<p>The model of an hOCR document is simple: a page contains areas, an area contains paragraphs, a paragraph contains lines, a line contains words. Each of these objects has a bounding box, which defines its position on the scanned page. hOCR4J provides various operations on bounding boxes in the <code>Bounds</code> class, including scaling, resizing, translating, unions, intersections, and more.</p>

<p>Using hOCR4J is also simple. First, we need to get our hOCR file and read the hOCR into a string. Then we can parse it:</p>

<p>```java
String hocr = … ; // load hOCR here</p>

<p>List<page> pages = HocrParser.parse(hocr);</page></p>

<p>Page page0 = pages.get(0);
```</p>

<p>We can now extract some text:</p>

<p><code>java
List&lt;String&gt; textLines = page0.getAllLinesAsStrings();
</code></p>

<p>We can only extract lines that satisfy some conditions:</p>

<p>```java
List<line> lines = page0.findAllLines(LineThat.matchesRegex("^IMPORTANT:"));</line></p>

<p>for (Line line: lines){
  String text = line.mkString();
  // …
}
```</p>

<p>We can look for words in italics:</p>

<p>```java
List<word> words = page0.getAllWords();</word></p>

<p>for (Word word: words){
  if (word.isItalic()){
    String w = word.getText();
    // …
  }
}
```</p>

<p>We can look for location of a word or phrase (spaces are ignored, as OCR sometimes inserts more or less of them):</p>

<p>```java
// let’s censor the name of the culprit
Page censoredPage = page0.mapLines(new Function&lt;Line,Line&gt;(){
  public Line apply(Line line){</p>

<pre><code>// we check if the line mentions culprit's name
final Bounds theCulpritIs = line.findBoundsOfWord("The culprit is");

if (theCulpritIs != null) {
  // we take bounds of the entire line
  Bounds full = line.getBounds();

  // and we calculate bounds of a line
  // that doesn't extend beyond words "The culprit is"
  Bounds remain = new Bounds(
    full.getLeft(), 
    full.getTop(), 
    theCulpritIs.getRight(), 
    full.getBottom());

  // finally, we trim our line
  return line.createBounded(remain);
} else {
  // all the other lines are left unmodified
  return line;
}   } });
</code></pre>

<p>return censoredPage;
```</p>

<p>In the near future, I’m planning a tutorial on extracting text columns from hOCR using hOCR4J.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Units 0.1 released]]></title>
    <link href="http://KarolS.github.io/blog/2014/01/02/units-0-1-released/"/>
    <updated>2014-01-02T20:26:00+01:00</updated>
    <id>http://KarolS.github.io/blog/2014/01/02/units-0-1-released</id>
    <content type="html"><![CDATA[<p>After several months of not-so-intensive work, I present the version 0.1 of the <em>Units</em> library: <a href="https://github.com/KarolS/units">https://github.com/KarolS/units</a>.</p>

<p><em>Units</em> is a Scala library for providing type-level units of measurements checked on compile time. The goal of the library was to provide as seamless as possible way to check if the units used in arithmetic expressions are correct.</p>

<p><em>If you have tried to compile it: Yes it does compile that long. A clean build takes 100 seconds on my i7.</em></p>

<p>Compile-time unit checking has multiple applications:</p>

<ul>
  <li>
    <p>scientists will be able to distinguish values in metres per second, metres, metres per second squared <a href="http://en.wikipedia.org/wiki/Mars_Climate_Orbiter">instead of crashing expensive space exploration equipment</a> or <a href="https://www.ismp.org/newsletters/acutecare/articles/A3Q99Action.asp">drugging a patient</a></p>
  </li>
  <li>
    <p>engineers will be able to distinguish values in metres, centimetres, feet, inches, litres, gallons <a href="http://en.wikipedia.org/wiki/Air_Canada_Flight_143">instead of running out of fuel in the middle of a flight</a> or <a href="http://spectrum.ieee.org/tech-talk/at-work/test-and-measurement/columbuss-geographical-miscalculations">thinking the distance to travel is many times shorter</a></p>
  </li>
  <li>
    <p>designers will be able to distinguish values in millimetres, inches, pixels, points</p>
  </li>
  <li>
    <p>economists will be able to distinguish values in euros, dollars, dollars per hour, ounces of gold</p>
  </li>
  <li>
    <p>game developers will be able to distinguish values in pixels, tiles, damage points, minerals, barrels of vespen gas</p>
  </li>
  <li>
    <p>network software developers will be able to distinguish values in kilobytes, kibibytes, kilobits, kilobits per second</p>
  </li>
  <li>
    <p>and so on and on</p>
  </li>
</ul>

<p>There are not many languages with units of measurement support, the first that comes to mind is <a href="http://msdn.microsoft.com/en-us/library/dd233243.aspx">F#</a>. I must admit that it is great at this. There also other languages that support units as a first-class language feature, and many that support units with a library. Those libraries vary in their expressibility and versatility, some of them only allow SI units, some of them require you to explicitly express relations between multiplied values, and some of them only support a limited subset of units. There have been earlier Scala libraries with units of measurements, but they all had severe limitations. <em>Units</em> library tries to be both expressive and versatile. While it’s not as powerful as F# built-in unit support, it definitely allows for quite a bit.</p>

<p>Enough of that, time for some examples that will showcase the main features.</p>

<!-- more -->

<p>Let’s start with something simple:</p>

<p>```scala</p>

<p>import io.github.karols.units._
import io.github.karols.units.SI._</p>

<p>val length1 = 1.of[metre]
val length2 = 2.of[metre]
val area1 = 1.of[square[metre]]
val area2 = length1 * length2 </p>

<p>length1 &lt; length2 // OK
area1 + area2 //OK
area1 + length2 // not OK, compile time error</p>

<p>```</p>

<p>The main difference you see is that all the values have a unit defined. The type of the variables in this example is <code>IntU[metre]</code> and <code>IntU[square[metre]]</code> respectively. It is an <code>AnyVal</code> wrapping a 64-bit <code>Long</code>. There is also <code>DoubleU</code>, which wraps 64-bit <code>Double</code>.</p>

<p>The library supports out-of-the-box most SI units, some Imperial and US Customary units, units of information and bandwidth, and many currencies. Most of the units can be semi-automatically converted, i.e. the following code:</p>

<p>```scala
def printMM(length: DoubleU[millimetre]) = {
  println(s”The length is $length mm.”)
}</p>

<p>printMM(1.of[inch].convert)</p>

<p>printMM(1.of[metre] + 1.of[millimetre])
```</p>

<p>will correctly print </p>

<p><code>
The length is 25.4 mm.
The length is 1001.0 mm.
</code></p>

<h3 id="implementation">Implementation</h3>

<p>How does it work, you ask. It’s simple. Down deep in the guts of the library, there lurks an implementation of a type-level map from strings to integers, with the following properties:</p>

<ul>
  <li>
    <p>strings are sorted lexicographically (so the equality can be structural)</p>
  </li>
  <li>
    <p>no integer value is equal to zero (so units to the zeroth power don’t matter)</p>
  </li>
</ul>

<p>For example, the above units are represented as <code>{"m" -&gt; 1}</code> and <code>{"m" -&gt; 2}</code> respectively.</p>

<p>You are probably curious how type-level datatypes are defined. I admit that they are implemented pretty simply. Here are <a href="https://github.com/KarolS/units/blob/master/units/src/main/scala/internal/Bools.scala">booleans</a>, here <a href="https://github.com/KarolS/units/blob/master/units/src/main/scala/internal/Integers.scala">integers</a>, here <a href="https://github.com/KarolS/units/blob/master/units/src/main/scala/internal/Strings.scala">characters and strings</a>, here <a href="https://github.com/KarolS/units/blob/master/units/src/main/scala/internal/SingleUnits.scala">unit names</a> and here <a href="https://github.com/KarolS/units/blob/master/units/src/main/scala/internal/UnitImpl.scala">unit maps</a>.</p>

<p>I’ll focus here on integers, because they’re simple enough to explain. Here’s the code (slightly simplified):</p>

<p>```scala</p>

<p>sealed trait TInteger {
    type Succ &lt;: TInteger
    type Pred &lt;: TInteger
    type Negate &lt;: TInteger
    type Add[X&lt;:TInteger] &lt;: TInteger
    type Mul[X&lt;:TInteger] &lt;: TInteger
    type ZeroNegPos[IfZero&lt;:ResultType, IfNeg[N&lt;:TInteger]&lt;:ResultType, IfPos[N&lt;:TInteger]&lt;:ResultType, ResultType] &lt;: ResultType
    type Equal[X&lt;:TInteger] &lt;: TBool
}
type LambdaNatFalse[N&lt;:TInteger] = False
sealed trait _0 extends TInteger {
    type Succ = Inc[_0]
    type Pred = Dec[_0]
    type Negate = _0
    type Add[X&lt;:TInteger] = X
    type Mul[X&lt;:TInteger] = _0
    type ZeroNegPos[IfZero&lt;:ResultType, IfNeg[N&lt;:TInteger]&lt;:ResultType, IfPos[N&lt;:TInteger]&lt;:ResultType, ResultType] = IfZero
    type Equal[X&lt;:TInteger] &lt;: X#ZeroNegPos[True, LambdaNatFalse, LambdaNatFalse, TBool]
}
sealed trait Inc[N &lt;: TInteger] extends TInteger {
    type Succ = Inc[Inc[N]]
    type Pred = N
    type Negate = Dec[N#Negate]
    type Add[X&lt;:TInteger] = N#Add[X#Succ]
    type Mul[X&lt;:TInteger] = N#Mul[X]#Add[X]
    type ZeroNegPos[IfZero&lt;:ResultType, IfNeg[N&lt;:TInteger]&lt;:ResultType, IfPos[N&lt;:TInteger]&lt;:ResultType, ResultType] = IfPos[N]
    type Equal[X&lt;:TInteger] &lt;: X#ZeroNegPos[False, LambdaNatFalse, N#Equal, TBool]
}
sealed trait Dec[N &lt;: TInteger] extends TInteger {
    type Succ = N
    type Pred = Dec[Dec[N]]
    TInteger]
    type Negate = Inc[N#Negate]
    type Add[X&lt;:TInteger] = N#Add[X#Pred]
    type Mul[X&lt;:TInteger] = N#Mul[X]#Add[X#Negate]
    type ZeroNegPos[IfZero&lt;:ResultType, IfNeg[N&lt;:TInteger]&lt;:ResultType, IfPos[N&lt;:TInteger]&lt;:ResultType, ResultType] = IfNeg[N]
    type Equal[X&lt;:TInteger] &lt;: X#ZeroNegPos[False, N#Equal, LambdaNatFalse, TBool]
}
```
As you can see:</p>

<ul>
  <li>
    <p>The code looks like normal code, but with <code>type</code> instead of <code>def</code> and with <code>Object#Method[Param]</code> instead of <code>object.method(param)</code>.</p>
  </li>
  <li>
    <p><code>_0</code> is the type-level zero, <code>Dec</code> is a type-level negative number, and <code>Inc</code> is a type-level positive number.</p>
  </li>
  <li>
    <p><code>Succ</code> and <code>Pred</code> are successor and predecessor respectively;</p>
  </li>
  <li>
    <p><code>Negate</code>, <code>Add</code> and <code>Mul</code> are defined recursively in a pretty straightforward way.</p>
  </li>
  <li>
    <p><code>ZeroNegPos</code> is integer pattern matching. It’s explicitly polymorphic. It takes four parameters: the result for when the number is zero, the function for when the number is positive, the function for when the number is negative, and the result type. If the result is zero, the first parameter is returned. If it’s not, the correct function is applied to the underlying value (the integer that is closer to zero), yielding the result. For example, let’s have a look at <code>Inc#Equal</code>: <code>type Equal[X&lt;:TInteger] &lt;: X#ZeroNegPos[False, LambdaNatFalse, N#Equal, TBool]</code></p>

    <ul>
      <li>
        <p>if <code>X</code> is <code>_0</code>, returns <code>False</code></p>
      </li>
      <li>
        <p>if <code>X</code> is <code>Dec[Y]</code>, returns <code>LambdaNatFalse[Y]</code>, i.e. <code>False</code></p>
      </li>
      <li>
        <p>if <code>X</code> is <code>Inc[Y]</code>, returns <code>N#Equal[Y]</code> (a recursive call)</p>
      </li>
    </ul>
  </li>
</ul>

<p>(<code>True</code> and <code>False</code> are type-level booleans)</p>

<p>Type-level strings are defined using a custom type-level encoding that supports only ASCII letters and several symbols useful for defining units (including the degree sign <code>°</code> and capital omega <code>Ω</code>).</p>

<p>You can probably guess how the arithmetic works:</p>

<ul>
  <li>
    <p>adding and subtracting values requires both units to match</p>
  </li>
  <li>
    <p>multiplying causes the values with the same keys be added together</p>
  </li>
  <li>
    <p>dividing causes the values with the same keys be subtracted</p>
  </li>
  <li>
    <p>all missing keys in the unit map have value zero</p>
  </li>
  <li>
    <p>if after adding or subtracting you get zero, you remove the key</p>
  </li>
</ul>

<h3 id="defining-units">Defining units</h3>

<p>Defining your own units is quite easy. The most basic thing you have to do is to define a unit and its type-level string. The string will be used to display the name of the unit (so better pick something that makes sense), but also to distinguish units themselves (so better pick something unique).</p>

<p>```scala
import io.github.karols.units._
import io.github.karols.units.defining._</p>

<p>type fortnight = DefineUnit[_f ~: _o ~: _r ~: _t ~: _n ~: _i ~: _g ~: _h ~: _t]
```</p>

<p>That’s it!</p>

<p>You can also define some conversions:</p>

<p>```scala
import io.github.karols.units.SI._</p>

<p>implicit val fortnight_to_day = one[fortnight].contains(14)[day]</p>

<p>println((1.of[fortnight] + 3.of[day]).mkString) // prints “17 d”
```</p>

<p>Sadly, you need to define conversions from fortnights to other units manually, and then you’ll have to define conversions of compound units, like from <em>mile/fortnight</em> to <em>kilometre/day</em>. The ratios have several operators defined to help with this, consult the documentation and source for more info.</p>

<h3 id="affine-spaces">Affine spaces</h3>

<p>The library preserves also another distinction: between normal values with units and elements of affine spaces. Affine spaces (also known as torsor spaces) are spaces that contain elements that cannot be added or multiplied, because those operations make no sense. For example, temperature is such space: there’s no reason to say “yesterday it was 3°C, today it’s 8°C, the sum of these is 11°C”. For these applications, the library provides <code>IntA</code> and <code>DoubleA</code> types. Subtracting two values of such type (using <code>--</code> operator) yields a value of <code>IntU</code> or <code>DoubleU</code> type, which we can call here the difference type.</p>

<p>The affine spaces often have an arbitrarily selected zero point. The zero point has no special properties, unlike the zero element of a vector space. It’s simply chosen to provide people a frame of reference.</p>

<p>Some examples of affine spaces, their zero points, and their difference spaces:</p>

<ul>
  <li>
    <p>temperature is an affine space, its zero point is the temperature of zero degrees, and its difference space is the space of temperature differences</p>
  </li>
  <li>
    <p>timestamps form an affine space, its zero point is an arbitrary moment in time (usually first midnight of the 1st day of January 1900, 1904, 1970, or 2000), and its difference space is time</p>
  </li>
  <li>
    <p>positions form an affine space, its zero point is usually called an origin, and its difference space is the corresponding vector space</p>
  </li>
</ul>

<p>Adding or multiplying temperatures, timestamps or positions doesn’t make sense. Adding to them a value from the corresponding difference space (this value is usually called an displacement) makes sense and yields another value from the affine space.</p>

<p><em>Units</em> library suggests using <code>IntA</code> and <code>DoubleA</code> for values from affine spaces and <code>IntU</code> and <code>DoubleU</code> for values from difference spaces.</p>

<p>Out-of-the-box <em>Units</em> defines Celsius and Fahrenheit scales and Unix timestamps in second, millisecond and nanosecond precisions.</p>

<h3 id="arrays">Arrays</h3>

<p>In Scala, the only unboxed collection types are arrays of primitive types. So all the other collections, and also arrays of custom value classes, are boxed. This leads to serious performance implications. You may think it would be easier to just use non-type safe code and revert back to raw doubles and longs.</p>

<p>To prevent this, the <em>Units</em> library provides array classes for <code>DoubleU</code>, <code>IntU</code>, <code>DoubleA</code> and <code>IntA</code>. According to few simple benchmarks that are available, the classes <code>DoubleUArray</code>, <code>IntUArray</code>, <code>DoubleAArray</code> and <code>IntAArray</code> are as fast as raw <code>Array[Double]</code> and <code>Array[Long]</code>.</p>

<p>Besides, you might have asked before:</p>

<blockquote>
  <p>Hey, you <strong>can</strong> add temperatures, provided you divide them immediately afterwards to get an average!</p>
</blockquote>

<p>All of these array classes provide an <code>avg</code> method, so you can write:</p>

<p>```scala
val t1 = 3.at[CelsiusScale]
val t2 = 8.at[CelsiusScale]</p>

<p>val average = IntAArray(t1,t2).avg</p>

<p>println(average.mkString) // prints 5.5 °C
```</p>

<h3 id="and-theres-more">And there’s more!</h3>

<p>The <em>Units</em> library also supports 2D and 3D vectors (both normal and affine), unboxed efficient vector arrays, semi-automatic affine space conversions, various ways to express functions with unit polymorphism (sadly, none of them as clean as in F#) and interoperability layers for many libraries (Scalaz, Spire, Slick, JodaTime, Algebird, Scalacheck, more to come).</p>

<p>The next goal is to get it to Sonatype.</p>

]]></content>
  </entry>
  
</feed>
