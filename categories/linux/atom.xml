<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | Karol Stasiak's Blog]]></title>
  <link href="http://KarolS.github.io/categories/linux/atom.xml" rel="self"/>
  <link href="http://KarolS.github.io/"/>
  <updated>2015-09-13T21:01:52+02:00</updated>
  <id>http://KarolS.github.io/</id>
  <author>
    <name><![CDATA[Karol Stasiak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Incremental synchronization of ZIP files in bandwidth-constrained environments]]></title>
    <link href="http://KarolS.github.io/blog/2015/09/13/incremental-synchronization-of-zip-files-in-bandwidth-constrained-environments/"/>
    <updated>2015-09-13T18:57:00+02:00</updated>
    <id>http://KarolS.github.io/blog/2015/09/13/incremental-synchronization-of-zip-files-in-bandwidth-constrained-environments</id>
    <content type="html"><![CDATA[<p>Suppose you have two ZIP archives on two different machines and you want to synchronize their contents with minimal network traffic, without much regard for the CPU usage, and you know that the target machine already contains the older version of the archive, which is mostly identical to the new version. For example, you have to upload a fat JAR with the new build over a metered connection, and the server literally sits in a garage at the other end of the country.</p>

<p>If the archive is small, uploading it in its entirety looks simple enough, but if it grows into dozens of megabytes, of which 90% is non-changing 3rd party code, it quickly becomes a waste of both time and bandwidth.</p>

<p>Time is money. And depending on your ISP, bandwidth can be money too.</p>

<p>Long story short, I’m going to assume that the target machine runs Linux, and the source machine runs either Windows or Linux. I am going to use <code>rsync</code> and <code>fuse-zip</code>.</p>

<p>Why those two? Because <code>fuse-zip</code> can convert a ZIP archive into a writeable filesystem, and <code>rsync</code> can sync a writeable filesystem with another. Details below.</p>

<!-- more -->

<h3 id="task-1--mount-the-archives">Task 1 – Mount the archives</h3>

<p>Create a mountpoint on the target machine, I’ll use <code>/tmp/z</code>. Then mount your archive using <code>fuse-zip</code>:</p>

<p><code>bash
$ sudo fuse-zip -o allow_other,rw,uid=`id -u`,gid=`id -g` /stuff/target.zip /tmp/z
</code></p>

<p>To test if it works, you create a file in the mounted filesystem. It would appear in the ZIP file after you unmount it.</p>

<p><code>bash
$ echo TEST &gt; /tmp/z/TEST_FILE_PLEASE_IGNORE
$ sudo umount /tmp/z
$ unzip -l /stuff/target.zip | grep TEST_FILE_PLEASE_IGNORE
</code></p>

<p><p class='info warning' data-title='Warning'>Do not modify the ZIP archive while it’s being mounted and do not interrupt the unmounting process if the archive was mounted for writing, as this can corrupt it.</p></p>

<p>If your source machine runs Linux, you can do the same, but mount the archive read-only:</p>

<p><code>bash
$ sudo fuse-zip -o allow_other,ro,uid=`id -u`,gid=`id -g` /stuff/source.zip /tmp/z
</code></p>

<p>You should experiment a bit if <code>sudo</code> and <code>usd</code>/<code>gid</code> are necessary.</p>

<p>If your souce machine runs Windows, you can use <a href="http://www.pismotechnic.com/pfm/">Pismo File Mount</a> to mount the archive as a drive and assign it a letter. It’s a GUI program, I haven’t found a scriptable alternative yet.</p>

<h3 id="task-2--synchronize-the-mounted-filesystems">Task 2 – Synchronize the mounted filesystems</h3>

<p>On the source machine:</p>

<p><code>
$ rsync --delete -zrucv -e ssh /tmp/z/ remoteuser@targethost:/tmp/z/
</code></p>

<p>Explanation for the parameters:</p>

<ul>
  <li>
    <p><code>-c</code> so that the files will be compared using checksums instead of modification dates. We do not care about nor trust  the dates here, what matters is content.</p>
  </li>
  <li>
    <p><code>-z</code> for the compression. Do not use the flag if the files themselves won’t compress well.</p>
  </li>
  <li>
    <p><code>-r</code> for recursive synchronization.</p>
  </li>
  <li>
    <p><code>-u</code> so only modified files are uploaded.</p>
  </li>
  <li>
    <p><code>--delete</code> so the files that are absent in the source archive will be deleted from the target archive. We want the target archive to have the same content as the source one, not more.</p>
  </li>
  <li>
    <p><code>-v</code> stands for verbose. Used once, makes <code>rsync</code> list all the files as they are being sent. You can skip this option, or repeat it several times, depending on your preference.</p>
  </li>
  <li>
    <p><code>-e ssh</code> picks the shell used to synchronize the files. SSH is the recommended one for most cases.</p>
  </li>
</ul>

<p>Note that the paths end with slashes, so <code>rsync</code> synchronizes the contents of the directories, not the directories themselves.</p>

<p>If the source mashine is running Windows, you can use <a href="">Cygwin</a>https://www.cygwin.com/, just install appropriate packages (you’ll need <code>rsync</code> and most likely also <code>openssh</code>). If you used Pismo File Mount to mount the ZIP to e.g. J: drive, use <code>/cygdrive/j/</code> as your source directory.</p>

<h3 id="task-3--unmount-the-filesystems">Task 3 – Unmount the filesystems</h3>

<p>On Linux (both source and target machine), do</p>

<p><code>bash
$ sudo umount /tmp/z
</code></p>

<p>You have to unmount the target archive so the changes take place, and the source archive so the next time you mount it, it would be current again.</p>

<h3 id="putting-it-all-together">Putting it all together</h3>

<p>Here is a small script that can be used to synchronize two ZIP archives:</p>

<p>```bash
#!/bin/bash</p>

<h1 id="put-all-the-necessary-values-here">put all the necessary values here</h1>
<p>REMOTEUSER=…
REMOTEHOST=…
SOURCEZIP=…
TARGETZIP=…</p>

<p>OS=<code>uname -o</code>
if [ “$OS” = Cygwin ] ; then
	# depends on where you mount it; assuming here the J: drive
	P=/cygdrive/j
else
	P=/tmp/z
	mkdir -p “$P”
	sudo umount “$P”
	sudo fuse-zip -o allow_other,uid=<code>id -u</code>,gid=<code>id -g</code>,ro “$SOURCEZIP” “$P”
fi</p>

<p>ssh $REMOTEUSER@$REMOTEHOST sudo jar_mount_rw
rsync –delete -zrucv -e “ssh” “$P/” $REMOTEUSER@$REMOTEHOST:/tmp/z/
ssh $REMOTEUSER@$REMOTEHOST sudo umount /tmp/z</p>

<p>if [ “$OS” = Cygwin ] ; then
	echo ‘Finished. Unmount the J: drive.’
else
	PID=”<code>pgrep fuse-zip</code>”
	if [ -z “$PID” ] ; then
		exit
	else
		sudo umount “$P”
	fi
fi
```</p>

<p>It requires this script to be present as <code>jar_mount_rw</code> on the target machine:</p>

<p>```bash jar_mount_rw
#!/bin/bash</p>

<h1 id="put-all-the-necessary-values-here-1">put all the necessary values here</h1>
<p>TARGETZIP=…</p>

<p>umount /tmp/z
mkdir -p /tmp/z
fuse-zip -o allow_other,rw,uid=<code>id -u</code>,gid=<code>id -g</code> “$TARGETZIP” /tmp/z
```</p>

<h3 id="results">Results</h3>

<p>I don’t have any hard data, but the overall effect is that a 40 MB JAR archive with only few files modified in it gets synchronized in few seconds, while it could take several minutes on slower connections to upload it whole.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating custom keyboard layouts for Linux]]></title>
    <link href="http://KarolS.github.io/blog/2013/11/18/creating-custom-keyboard-layouts-for-linux/"/>
    <updated>2013-11-18T21:05:00+01:00</updated>
    <id>http://KarolS.github.io/blog/2013/11/18/creating-custom-keyboard-layouts-for-linux</id>
    <content type="html"><![CDATA[<p>I think almost every one of you has some beef with your keyboard layout. There are characters you’re never going to use, there are characters you’d love to use but they’re missing (and you don’t like/can’t use the compose key for them), and so on.</p>

<p>For example, this is the default Polish layout in Linux:</p>

<p><img src="/images/layout-pl.png"></p>

<p>A keen eye can notice several things that could be improved:</p>

<ul>
  <li>
    <p>many characters can be input in multiple ways: <code>[</code> (as <code>[</code> or as <code>AltGr-9</code>), <code>ł</code> (as <code>AltGr-w</code> or <code>AltGr-l</code>), <code>&amp;</code> (as <code>Shift-7</code> or <code>AltGr-Shift-k</code>), <code>@</code> (as <code>Shift-2</code> or <code>AltGr-q</code>),</p>
  </li>
  <li>
    <p>the layout has some unassigned combinations (for example <code>AltGr-Shift-4</code>),</p>
  </li>
  <li>
    <p>some important characters are missing: <code>€</code> (the euro sign) and <code>„</code> (Polish opening quote),</p>
  </li>
  <li>
    <p>since I can use the compose key, I don’t need all those arbitrarily assigned dead keys on the right.</p>
  </li>
</ul>

<p>Of course your keyboard layout may have different problems.</p>

<p><strong>Disclaimer:</strong> The following was done on Ubuntu 12.04 with Unity DE, I don’t guarantee it will work on other distros. In particular, the file paths can differ.</p>

<p>How to create a new one, you ask? That’s actually pretty simple.</p>

<ul>
  <li>
    <p>layout definitions are in the <code>/usr/share/X11/xkb/symbols</code> directory,</p>
  </li>
  <li>
    <p>layout metadata are in the <code>/usr/share/X11/xkb/rules/evdev.xml</code> file.</p>
  </li>
</ul>

<p>Let’s first define our layout. The <code>/usr/share/X11/xkb/symbols</code> contains files, each corresponding to a language. Some layouts can belong to several languages, but they’re defined in only one of the files. If your layout is supposed to be listed under one language in the keyboard setting anyway, you’ll have to add it to the correct file. Since my keyboard layout was to be mostly an improvement on top of the Polish language layout, I decided to add it to <code>/usr/share/X11/xkb/symbols/pl</code>.</p>

<!-- more -->

<p>The format of this file is pretty simple. I’m going to analyse the default Polish layout line by line.</p>

<p><code>
partial default alphanumeric_keys
xkb_symbols "basic" {
</code></p>

<p><code>default</code> means that this is the default layout in this file (other layouts don’t have this tag).</p>

<p><code>"basic"</code> is the indentifier of this layout within the file.</p>

<p><code>
    include "latin"
</code></p>

<p>Since most layouts are similar, the <code>include</code> directive simply inserts all key definitions from one layout to another. This one includes the (default) <code>"basic"</code> layout from the <code>/usr/share/X11/xkb/symbols/latin</code> file.</p>

<p><code>
    name[Group1]="Polish";
</code></p>

<p>No clue what it does. It’s recommended to set it to a full English name for the layout.</p>

<p>```
    key <ad01>  { [         q,          Q ] };
    key <ad02>  { [         w,          W ] };
    key <ad03>  { [         e,          E,      eogonek,      Eogonek ] };
    key <ad09>  { [         o,          O,       oacute,       Oacute ] };</ad09></ad03></ad02></ad01></p>

<pre><code>key &lt;AC01&gt;  { [         a,          A,      aogonek,      Aogonek ] };
key &lt;AC02&gt;  { [         s,          S,       sacute,       Sacute ] };
key &lt;AC04&gt;  { [         f,          F ] };

key &lt;AB01&gt;  { [         z,          Z,    zabovedot,    Zabovedot ] };
key &lt;AB02&gt;  { [         x,          X,       zacute,       Zacute ] };
key &lt;AB03&gt;  { [         c,          C,       cacute,       Cacute ] };
key &lt;AB06&gt;  { [         n,          N,       nacute,       Nacute ] }; ```
</code></pre>

<p>Those are the definitions that make the Polish layout different from the default Latin one.Each line contains: </p>

<ul>
  <li>
    <p>the <code>key</code> keyword,</p>
  </li>
  <li>
    <p>a symbol defining the physical key,</p>
  </li>
  <li>
    <p>a list of characters associated with that key, from left to right: the default one, with Shift key, with AltGr key, with both Shift and AltGr keys.</p>
  </li>
</ul>

<p>The names of the physical keys are as follows (I’m referring to keys by their American/Polish usage):</p>

<ul>
  <li>
    <p><code>&lt;TLDE&gt;</code> for the grave accent/tilde key</p>
  </li>
  <li>
    <p><code>&lt;BKSL&gt;</code> for the backslash/bar key</p>
  </li>
  <li>
    <p><code>&lt;AB01&gt;</code>, <code>&lt;AB02&gt;</code> and so on for <code>Z</code>, <code>X</code> … keys</p>
  </li>
  <li>
    <p><code>&lt;AC01&gt;</code>, <code>&lt;AC02&gt;</code> and so on for <code>A</code>, <code>S</code> … keys</p>
  </li>
  <li>
    <p><code>&lt;AD01&gt;</code>, <code>&lt;AD02&gt;</code> and so on for <code>Q</code>, <code>W</code> … keys</p>
  </li>
  <li>
    <p><code>&lt;AE01&gt;</code>, <code>&lt;AE02&gt;</code> and so on for <code>1</code>, <code>2</code> … keys</p>
  </li>
</ul>

<p>Note: this refers to their <em>physical</em> layout, so I could also say that <code>AB</code> is the row above the spacebar, <code>AC</code> is the row with caps lock key, <code>AD</code> is the row with tab key, and <code>AE</code> is the row with digits, and the numbering goes from left to right. For example, <code>&lt;AD11&gt;</code> is labelled <code>[</code> on the American keyboard and <code>Ü</code> on the German one; <code>&lt;AB01&gt;</code> is <code>Z</code> on the American keyboard, <code>W</code> on the French keyboard, and <code>Y</code> on the German keyboard. <code>&lt;TLDE&gt;</code> is always in the top left, just under the <code>Esc</code> key, and <code>&lt;BKSL&gt;</code> is in either <code>AC</code>, <code>AD</code> or <code>AE</code> row (depending on the keyboard).</p>

<p>Also, for some reason trying to override a key with a shorter definition doesn’t work.</p>

<p>As for the character codes, you can look around the files to learn them, or just use Unicode codepoints in hexadecimal, for example <code>U0041</code> and <code>A</code> are synonymous.</p>

<p><code>
    include "kpdl(comma)"
</code></p>

<p>This defines the behaviour of the decimal point key on the numpad. (More accurately, imports such behaviour override from <code>/usr/share/X11/xkb/symbols/kpdl</code>.)</p>

<p><code>
    include "level3(ralt_switch)"
};
</code></p>

<p>And finally, this defines how the 3rd level (the one with accented characters, the one I referred to as “AltGr”) is accessed. In this case, it’s with the right Alt key.</p>

<p>So I created my own layout by copying the existing one and modifying it:</p>

<p><code>
partial alphanumeric_keys
xkb_symbols "custom3" {
    include "latin"
</code></p>

<p><code>"custom3"</code> is the identifier of my new layout (why 3, I’ll explain later). My new layout is not defined as the default one.</p>

<p><code>
    name[Group1]="Polish (custom)";
</code></p>

<p>No clue why I did this, but it looks consistent with the rest of the file, so I guess it’s correct.</p>

<p>```
    key <ae07>  { [ 7, ampersand, copyright, seveneighths ] };
    key <ae08>  { [ 8, asterisk, U221E, trademark ] };
    key <ae09>  { [ 9, parenleft, guillemotleft, plusminus ] };
    key <ae10>  { [ 0, parenright, guillemotright, degree ] };</ae10></ae09></ae08></ae07></p>

<pre><code>key &lt;AD03&gt;  { [         e,          E,      eogonek,      Eogonek ] };
key &lt;AD09&gt;  { [         o,          O,       oacute,       Oacute ] };

key &lt;AC01&gt;  { [         a,          A,      aogonek,      Aogonek ] };
key &lt;AC02&gt;  { [         s,          S,       sacute,       Sacute ] };
key &lt;AC04&gt;  { [         f,          F ] };

key &lt;AB01&gt;  { [         z,          Z,    zabovedot,    Zabovedot ] };
key &lt;AB02&gt;  { [         x,          X,       zacute,       Zacute ] };
key &lt;AB03&gt;  { [         c,          C,       cacute,       Cacute ] };
key &lt;AB06&gt;  { [         n,          N,       nacute,       Nacute ] };

include "kpdl(comma)"

include "level3(ralt_switch)"


key &lt;TLDE&gt;  { [ grave, asciitilde, notsign, section ] };

key &lt;AE04&gt;  { [ 4, dollar, onequarter, EuroSign ] };
key &lt;AE07&gt;  { [ 7, ampersand, copyright, seveneighths ] };
key &lt;AE08&gt;  { [ 8, asterisk, U221E, trademark ] };
key &lt;AE09&gt;  { [ 9, parenleft, guillemotleft, plusminus ] };
key &lt;AE10&gt;  { [ 0, parenright, guillemotright, degree ] };
key &lt;AE11&gt;  { [ minus, underscore, U2013, questiondown ] };
key &lt;AE12&gt;  { [ equal, plus, U2260, Greek_SIGMA ] };

key &lt;AD01&gt;  { [ q, Q, Greek_pi, Greek_OMEGA ] };
key &lt;AD02&gt;  { [ w, W, cent, U20A9 ] };
key &lt;AD11&gt;  { [bracketleft,  braceleft, udiaeresis, Udiaeresis ] };
key &lt;AD12&gt;  { [bracketright, braceright, ssharp,  ediaeresis ] };

key &lt;BKSL&gt;  { [backslash, bar, eacute, egrave] };

key &lt;AC07&gt;  { [ j, J, doublelowquotemark, singlelowquotemark] };
key &lt;AC08&gt;  { [ k, K, kra, U2030] };
key &lt;AC10&gt;  { [ semicolon,    colon, odiaeresis, Odiaeresis ] };
key &lt;AC11&gt;  { [apostrophe, quotedbl, adiaeresis,  Adiaeresis ] };

key &lt;AB08&gt;  { [ comma,  less, ellipsis, multiply ]  };
key &lt;AB10&gt;  { [ slash, question, agrave, idiaeresis ] };
</code></pre>

<p>};
```</p>

<p>As you can see, I added an euro sign to <code>Shift-AltGr-4</code>, opening quotes to the <code>J</code> key, and so on.</p>

<p>Okay, my layout is ready. Time to hook it in.</p>

<p>Now we’re editing the <code>/usr/share/X11/xkb/rules/evdev.xml</code> file. The interesting fragment looks like this:</p>

<p><code>xml
    &lt;layout&gt;
      &lt;configItem&gt;
        &lt;name&gt;pl&lt;/name&gt;
        &lt;shortDescription&gt;pl&lt;/shortDescription&gt;
        &lt;description&gt;Polish&lt;/description&gt;
        &lt;languageList&gt;
          &lt;iso639Id&gt;pol&lt;/iso639Id&gt;
        &lt;/languageList&gt;
      &lt;/configItem&gt;
      &lt;variantList&gt;
        &lt;variant&gt;
          &lt;configItem&gt;
            &lt;name&gt;qwertz&lt;/name&gt;
            &lt;description&gt;Polish (qwertz)&lt;/description&gt;
          &lt;/configItem&gt;
        &lt;/variant&gt;
</code></p>

<p>What does it mean? <code>configItem/name</code> is the name of the file in <code>/usr/share/X11/xkb/symbols</code> that contains layout definitions. <code>languageList</code> is a list of languages which that file supports. <code>variantList</code> is a list of alternative layouts that are defined in that file and their user-friendly names (which will be translated if there’s translation for them).</p>

<p>Since I didn’t want to add the translation for the name of my layout, I simply added an entry with the name hardcoded in Polish:</p>

<p><code>xml
        &lt;variant&gt;
          &lt;configItem&gt;
            &lt;name&gt;custom3&lt;/name&gt;
            &lt;description&gt;Polski (własny)&lt;/description&gt;
          &lt;/configItem&gt;
        &lt;/variant&gt;
</code></p>

<p>And that’s all!</p>

<p>Also, it’s time to explain why it’s <code>custom3</code>, not <code>custom</code>. Since those files are cached in memory by the DE, if you change the layout in the <code>/usr/share/X11/xkb/symbols/*</code> file, those changes won’t be reloaded. Since I didn’t want to restart everything just to test the layout, I solved that problem by adding 2 (and later 3) to the identifier.</p>

<p>And this is the result:</p>

<p><img src="/images/layout-pl-custom.png"></p>

<p>Still not perfect, but way better.</p>
]]></content>
  </entry>
  
</feed>
